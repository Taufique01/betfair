#!/usr/bin/env python3
import argparse
import json
import os
import sys
import csv
import time as _time
from datetime import datetime, date, timedelta, timezone, time as dtime
from zoneinfo import ZoneInfo

# Fake market
from fakemarket import (
    get_fake_markets,
    determine_fav_and_odds_override,
    await_result_override
)

# Core imports from bet_watch (real mode)
from bet_watch import (
    create_client,
    load_config,
    get_today_markets as real_get_today_markets,
    determine_fav_and_odds as real_determine_fav_and_odds,
    append_logs,
    await_result as real_await_result
)

# Timezone for Betfair (BST)
LONDON = ZoneInfo("Europe/London")

# CSV headers
CSV_HEADERS = [
    'timestamp', 'market_id', 'race_name', 'track', 'date',
    'leg', 'selection', 'odds', 'stake', 'result', 'profit', 'balance'
]

# Configuration files
STATE_FILE = 'chase_state.json'
BALANCE_FILE = 'bank_balance.json'
STRAT_FILE = 'strat_settings.json'
LOW_WIN_FILE = 'low_win_races.json'
TRACK_GRADE_FILE = 'track_grades.json'

# Output logs
TXT_FILE = 'chase_bets.txt'
JSON_FILE = 'chase_bets.json'
CSV_FILE = 'chase_bets.csv'

# Seconds before start to place bet
BET_BUFFER = 60


def load_json(path):
    with open(path, 'r') as f:
        return json.load(f)


def load_initial_balance():
    if not os.path.exists(BALANCE_FILE):
        print(f"Error: '{BALANCE_FILE}' not found.", file=sys.stderr)
        sys.exit(1)
    data = load_json(BALANCE_FILE)
    if 'balance' not in data:
        print(f"Error: 'balance' key missing in {BALANCE_FILE}.", file=sys.stderr)
        sys.exit(1)
    return float(data['balance'])


def load_state():
    if os.path.exists(STATE_FILE):
        return load_json(STATE_FILE)
    return {
        'balance': None,
        'leg': 0,
        'accumulated_losses': 0.0,
        'prev_stake': None,
        'chase_active': False
    }


def save_state(state):
    with open(STATE_FILE, 'w') as f:
        json.dump(state, f, indent=2)


def append_result(record):
    try:
        # Ensure CSV has header
        if not os.path.exists(CSV_FILE) or os.path.getsize(CSV_FILE) == 0:
            with open(CSV_FILE, 'w', newline='') as f:
                writer = csv.DictWriter(f, fieldnames=CSV_HEADERS)
                writer.writeheader()
        # Append to CSV
        with open(CSV_FILE, 'a', newline='') as f:
            writer = csv.DictWriter(f, fieldnames=CSV_HEADERS)
            writer.writerow(record)
        # Append to JSON
        with open(JSON_FILE, 'a') as f:
            f.write(json.dumps(record) + '\n')
        # Append to TXT
        with open(TXT_FILE, 'a') as f:
            f.write(
                f"{record['timestamp']} | {record['market_id']} | {record['race_name']} | "
                f"{record['track']} | {record['date']} | leg {record.get('leg', '?')} | "
                f"{record.get('selection', '?')} | {record['result'].upper()} | profit {record['profit']:.2f} | "
                f"balance {record['balance']:.2f}\n"
            )
    except Exception as e:
        print(f"Failed to append result: {e}", file=sys.stderr)


def should_skip(event_name, track_name, low_win, track_grades):
    for entry in low_win:
        if entry.get('event_name') == event_name and entry.get('skip'):
            return True
    return track_grades.get(track_name, {}).get('skip', False)


def calculate_first_stake(balance, settings):
    cap = settings['first_bet']['balance_cap']
    pct = settings['first_bet']['percentage']
    max_amt = settings['first_bet']['max_amount']
    base = min(balance, cap)
    return min(base * pct, max_amt)


def calculate_next_stake(prev_stake, odds, losses, settings):
    for rule in settings['multipliers']:
        if 'multiplier' in rule:
            if rule.get('min_odds', 0) <= odds <= rule.get('max_odds', float('inf')):
                return prev_stake * rule['multiplier']
        else:
            if odds < rule.get('max_odds', float('inf')):
                if odds <= 1:
                    # fallback if odds too low to compute buffer
                    return prev_stake * settings['multipliers'][0].get('multiplier', 1.5)
                target = losses * rule['profit_buffer_multiplier']
                return target / (odds - 1)
    first = settings['multipliers'][0]
    return prev_stake * first.get('multiplier', 1.5)


def place_chase_bet(betting, market, fav, stake, odds, await_result_fn):
    bet = {
        'selection_id': fav['selection_id'],
        'runner_name': fav['runner_name'],
        'odds': odds,
        'result': 'PENDING'
    }
    location = market.event.name.split()[0] if getattr(market.event, 'name', '') else ''
    race_name = market.market_name
    race_start = market.market_start_time
    append_logs(bet, location, race_name, race_start)
    await_result_fn(betting, market, f"{location} {race_name}", bet, race_start)
    win = bet.get('result') == 'WON'
    profit = stake * (odds - 1) if win else -stake
    return {'win': win, 'profit': profit}


def _make_base_record(now, market):
    date_str = now.strftime('%Y-%m-%d')
    base = {
        'timestamp': now.strftime('%Y-%m-%d %H:%M:%S'),
        'market_id': market.market_id if market else '',
        'race_name': market.market_name if market else '',
        'track': market.event.name.split()[0] if market and getattr(market.event, 'name', '') else '',
        'date': date_str
    }
    return base


def run_chase(settings, low_win_file, track_grade_file, betting,
              fetch_markets_fn,
              determine_fav_and_odds_fn,
              await_result_fn):
    state = load_state()
    if state['balance'] is None:
        state['balance'] = load_initial_balance()
    balance = state['balance']

    low_win_list = load_json(low_win_file)
    grades = load_json(track_grade_file)
    markets = fetch_markets_fn(betting)

    for market in sorted(markets, key=lambda m: m.market_start_time):
        now = datetime.now(LONDON)
        cutoff_cfg = datetime.strptime(settings['cutoff_time'], '%H:%M')
        cutoff = datetime(
            now.year, now.month, now.day,
            cutoff_cfg.hour, cutoff_cfg.minute,
            tzinfo=LONDON
        )
        if now >= cutoff and not state['chase_active']:
            print(f"Cutoff reached: {cutoff}", flush=True)
            break

        event_name = market.market_name
        full_track = market.event.name
        if should_skip(event_name, full_track, low_win_list, grades):
            record = {
                **_make_base_record(now, market),
                **{
                    'leg': None,
                    'selection': '',
                    'odds': None,
                    'stake': 0.0,
                    'result': 'skipped',
                    'profit': 0.0,
                    'balance': round(balance, 2)
                }
            }
            append_result(record)
            continue

        # wait until buffer
        start_local = market.market_start_time.astimezone(LONDON)
        bet_time = start_local - timedelta(seconds=BET_BUFFER)
        wait = (bet_time - now).total_seconds()
        if wait > 0:
            print(f"Waiting {int(wait)}s until {bet_time}", flush=True)
            _time.sleep(wait)
            now = datetime.now(LONDON)

        # start chase if needed
        if not state['chase_active'] and now < cutoff:
            state.update({
                'leg': 1,
                'accumulated_losses': 0.0,
                'prev_stake': calculate_first_stake(balance, settings),
                'chase_active': True
            })
            save_state(state)
        elif not state['chase_active']:
            break

        leg = state['leg']
        fav, odds = determine_fav_and_odds_fn(betting, market)
        if not fav or odds is None:
            print(f"Skipping market {market.market_name}: favorite or odds missing (fav={fav}, odds={odds})",
                  flush=True)
            continue

        stake = state['prev_stake'] if leg < settings['max_chase_legs'] else balance
        result = place_chase_bet(betting, market, fav, stake, odds, await_result_fn)
        win, profit = result['win'], result['profit']

        if win:
            balance += profit
            state['chase_active'] = False
        else:
            state['accumulated_losses'] += stake
            balance -= stake
            if leg < settings['max_chase_legs']:
                state['prev_stake'] = calculate_next_stake(
                    state['prev_stake'], odds, state['accumulated_losses'], settings
                )
            else:
                state['chase_active'] = False

        state['leg'] = leg + 1
        state['balance'] = balance
        save_state(state)

        record = {**_make_base_record(now, market),
                  **{
                      'leg': leg,
                      'selection': fav['runner_name'],
                      'odds': round(odds, 2),
                      'stake': round(stake, 2),
                      'result': 'win' if win else 'loss',
                      'profit': profit,
                      'balance': round(balance, 2)
                  }}
        append_result(record)

    now = datetime.now(LONDON)
    eod = {
        **_make_base_record(now, None),
        'leg': None,
        'selection': '',
        'odds': None,
        'stake': 0.0,
        'result': 'end_of_day',
        'profit': 0.0,
        'balance': round(state.get('balance', 0.0), 2)
    }
    append_result(eod)


def _reset_and_sleep_to_5am(now_local):
    state = load_state()
    state.update({
        'leg': 0,
        'accumulated_losses': 0.0,
        'prev_stake': None,
        'chase_active': False,
    })
    save_state(state)

    tomorrow = now_local.date() + timedelta(days=1)
    next_5am = datetime.combine(tomorrow, dtime(5, 0), tzinfo=LONDON)
    now_utc = datetime.now(timezone.utc)
    secs = (next_5am.astimezone(timezone.utc) - now_utc).total_seconds()
    print(f"Sleeping until next run at {next_5am} ({int(secs)}s)", flush=True)
    _time.sleep(max(secs, 60))


def run_forever(settings, low_win_file, track_grade_file, client, logout,
                fetch_markets_fn,
                determine_fav_and_odds_fn,
                await_result_fn):
    # validate required settings early
    required = ['cutoff_time', 'multipliers', 'first_bet', 'max_chase_legs']
    for key in required:
        if key not in settings:
            print(f"Fatal: missing required key '{key}' in strategy file.", file=sys.stderr)
            sys.exit(1)

    cutoff_t = datetime.strptime(settings['cutoff_time'], '%H:%M').time()
    buffer_s = settings.get('bet_buffer_seconds', BET_BUFFER)

    try:
        while True:
            now_utc = datetime.now(timezone.utc)
            now_local = datetime.now(LONDON)

            if now_local.time() >= cutoff_t:
                # emit end-of-day before resetting
                state = load_state()
                now = datetime.now(LONDON)
                eod = {
                    **_make_base_record(now, None),
                    'leg': None,
                    'selection': '',
                    'odds': None,
                    'stake': 0.0,
                    'result': 'end_of_day',
                    'profit': 0.0,
                    'balance': round(state.get('balance', 0.0), 2)
                }
                append_result(eod)
                _reset_and_sleep_to_5am(now_local)
                continue

            markets = fetch_markets_fn(client)

            def to_utc_or_fail(dt, market_name):
                if getattr(dt, 'tzinfo', None) is None:
                    raise ValueError(f"Encountered naive market_start_time for market {market_name}")
                return dt.astimezone(timezone.utc)

            upcoming = []
            for m in markets:
                try:
                    if to_utc_or_fail(m.market_start_time, m.market_name) > now_utc:
                        upcoming.append(m)
                except ValueError as e:
                    print(f"Timezone error skipping market: {e}", flush=True)
                    continue
            upcoming = sorted(upcoming, key=lambda m: m.market_start_time)

            if not upcoming:
                # emit end-of-day before resetting
                state = load_state()
                now = datetime.now(LONDON)
                eod = {
                    **_make_base_record(now, None),
                    'leg': None,
                    'selection': '',
                    'odds': None,
                    'stake': 0.0,
                    'result': 'end_of_day',
                    'profit': 0.0,
                    'balance': round(state.get('balance', 0.0), 2)
                }
                append_result(eod)
                _reset_and_sleep_to_5am(now_local)
                continue

            next_market = upcoming[0]

            start_local = next_market.market_start_time.astimezone(LONDON)
            wake_time = start_local - timedelta(seconds=buffer_s)
            wait_s = (wake_time - now_local).total_seconds()
            if wait_s > 0:
                print(f"Sleeping {int(wait_s)}s until {wake_time}", flush=True)
                _time.sleep(wait_s)

            try:
                state = load_state()

                fav, odds = determine_fav_and_odds_fn(client, next_market)
                if not fav or odds is None:
                    print(f"❌ No favorite/odds for {next_market.market_name}, skipping", flush=True)
                    continue

                if not state.get('chase_active', False):
                    stake = calculate_first_stake(state.get('balance', 0.0), settings)
                else:
                    stake = calculate_next_stake(
                        state.get('prev_stake'),
                        odds,
                        state.get('accumulated_losses', 0.0),
                        settings
                    )

                outcome = place_chase_bet(client, next_market, fav, stake, odds, await_result_fn)
                win = outcome['win']
                profit = outcome['profit']

                # Determine current leg for record
                current_leg = state.get('leg', 0) if state.get('chase_active', False) else 1

                if win:
                    state['leg'] = 0
                    state['chase_active'] = False
                    state['prev_stake'] = None
                    state['accumulated_losses'] = 0.0
                else:
                    state['leg'] = state.get('leg', 0) + 1
                    state['chase_active'] = True
                    state['prev_stake'] = stake
                    state['accumulated_losses'] = state.get('accumulated_losses', 0.0) + stake

                state['balance'] = state.get('balance', 0.0) + profit

                # Log the outcome
                now = datetime.now(LONDON)
                record = {
                    **_make_base_record(now, next_market),
                    **{
                        'leg': current_leg,
                        'selection': fav['runner_name'] if fav else '',
                        'odds': round(odds, 2) if odds is not None else None,
                        'stake': round(stake, 2),
                        'result': 'win' if win else 'loss',
                        'profit': profit,
                        'balance': round(state['balance'], 2)
                    }
                }
                append_result(record)

                save_state(state)

            except Exception as e:
                print(f"Error during chase leg for market {next_market.market_name}: {e}", flush=True)
                continue

    finally:
        logout()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--replay", action="store_true", help="Replay last ghost bet(s) as fake upcoming markets")
    args = parser.parse_args()

    use_fake = args.replay or os.environ.get("REPLAY") == "1"

    try:
        settings = load_json(STRAT_FILE)
    except FileNotFoundError:
        print(f"Strategy file {STRAT_FILE} not found.", file=sys.stderr)
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"Strategy file {STRAT_FILE} is invalid JSON: {e}", file=sys.stderr)
        sys.exit(1)

    client, logout = create_client(load_config())

    if use_fake:
        fake_markets = get_fake_markets(
            "ghost_bets.txt",
            include_last_n=2,
            offset_seconds=90,
            include_pending=False
        )
        if not fake_markets:
            print("Warning: replay enabled but no valid entries found in ghost_bets.txt", flush=True)

        fetch_markets = lambda *args, **kwargs: fake_markets
        determine_fav_and_odds_fn = determine_fav_and_odds_override
        await_result_fn = await_result_override
    else:
        fetch_markets = real_get_today_markets
        determine_fav_and_odds_fn = real_determine_fav_and_odds
        await_result_fn = real_await_result

    run_forever(settings, LOW_WIN_FILE, TRACK_GRADE_FILE, client, logout,
                fetch_markets, determine_fav_and_odds_fn, await_result_fn)


if __name__ == '__main__':
    main()

